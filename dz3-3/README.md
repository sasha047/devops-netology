## Домашнее задание к занятию "3.3. Операционные системы. Лекция 1"  
>Установил:  
  
![Рис.0](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/check-1.png)  
![Рис.0](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/check-2.png)  


# Задание  
## 1. Какой системный вызов делает команда cd?  
  
В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin,   
поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'.   
В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте.  
  
Вам нужно найти тот единственный, который относится именно к cd.   
Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.  
  
Ответ:  
>Системный вызов execve выполняет программу cd  
  
![Рис.1-1](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/1-1.png)  


  
>Системный вызов stat передает параметр tmp  
>Системный вызов меняет каталог  

![Рис.1-2](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/1-2.png)  

  
  
## 2. Попробуйте использовать команду file на объекты разных типов в файловой системе. Например:  
  
     vagrant@netology1:~$ file /dev/tty  
     /dev/tty: character special (5/0)  
     vagrant@netology1:~$ file /dev/sda  
     /dev/sda: block special (8/0)  
     vagrant@netology1:~$ file /bin/bash  
     /bin/bash: ELF 64-bit LSB shared object, x86-64  
  Используя strace выясните, где находится база данных file, на основании которой она делает свои догадки.  
## Решение:    
>Прочитал про утилиту strace, с ней же описывается и используется утилита ltrace  
  
Ответ:  
>openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3  

![Рис.2-1](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/2-1.png)  
![Рис.2-2](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/2-2.png)  

## 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof),   
## однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет.   
## Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается.   
## Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла   
## (чтобы освободить место на файловой системе).  
Решение:  

>Все действия проводил на своем сервере. Так как логи zabbix мне пока не нужны, могу их чистить =)  
>Выбираю файл, который занят процессом и постоянно записывается  
![Рис.3-1](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/3-1.png)  

>Выполняю команду pstree -up. Смотрим PID процесса zabbix  

![Рис.3-2](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/3-2.png)  

>Выполняю команду: lsof -p 424970 | grep log. Види два дескриптора  

![Рис.3-3](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/3-3.png)  

>Удаляю файл и снова выполняю команду lsof -p 424970 | grep log  

![Рис.3-4](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/3-4.png)  

>Отправляю вывод STDOUT в "пустоту". И смотрим размер файла  

![Рис.3-5](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/3-5.png)  

## 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?  
Ответ:  
>Zombie processes (зомби-процесс) неактивен, но контролируется родительским процессом,   
>пока тот не решит, что статус выхода дочерних процессов больше не нужен.   
>Он не использует ресурсы и не может быть запланирован для выполнения.   
>Иногда родительский процесс удерживает дочерний процесс в состоянии зомби,   
>чтобы гарантировать, что будущие дочерние процессы не получат тот же PID.   
>Если уничтожить родителя зомби-процесса, зомби-процесс тоже умрет.   
  
>На сайте stackoverflow было найдено такое решение, для убийства zombie-процессов  

>>kill $(ps -A -ostat,ppid | awk '/[zZ]/ && !a[$2]++ {print $2}')  


## 5. В iovisor BCC есть утилита opensnoop:  
  
     root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop    
     /usr/sbin/opensnoop-bpfcc    
## На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты?   
## Воспользуйтесь пакетом bpfcc-tools для Ubuntu 22.04. Дополнительные сведения по установке.  
Решение:  
>Воспользовался командой: sudo /usr/sbin/opensnoop-bpfcc -d 1  

![Рис.5](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/5.png)  


## 6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, 
## где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
Отает:  

![Рис.6-1](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/6-1.png)  
![Рис.6-2](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/6-2.png)  


## 7. Чем отличается последовательность команд через ; и через && в bash? Например:  

     root@netology1:~# test -d /tmp/some_dir; echo Hi  
     Hi  
     root@netology1:~# test -d /tmp/some_dir && echo Hi  
     root@netology1:~#  

Решение:  
>Последовательность команд через ; выполнит все команды независимо от результатов выполнения предыдущей.  
>Если запустить их через &&, то следущая за первой командой  будет выполнена только в случае успеха выполения первой.   

## Есть ли смысл использовать в bash &&, если применить set -e?  
  
>Параментр set -e предписывает bash немедленно завершить работу,   
>если какая-либо команда имеет ненулевой статус завершения.  
>&&  вместе с set -e думаю не имеет смысла, так как при ошибке , выполнение команд остановится.   

## 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?    

Ответ:  
>Добавить в начало скрипта: set -euxo pipefail  
>Обозначения:  
  
>>set -e - прекращает выполнение скрипта если команда завершилась ошибкой,   
>>выводит в stderr строку с ошибкой. Обойти эту проверку можно добавив в пайплайн к команде true: mycommand | true.  

>>set -u - прекращает выполнение скрипта, если встретилась несуществующая переменная.  

>>set -x - выводит выполняемые команды в stdout перед выполненинем.  

>>set -o pipefail - прекращает выполнение скрипта, даже если одна из частей пайпа завершилась ошибкой.   
>>В этом случае bash-скрипт завершит выполнение, если mycommand вернёт ошибку,   
>>не смотря на true в конце пайплайна: mycommand | true.  

## 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся 
## статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) 
## что значат дополнительные к основной заглавной буквы статуса процессов. 
## Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

Решение: 
>Выполнил команду: ps ax -o stat >> file2.txt. Сохраним все полученные значения в файл fail2.txt  
>Далее отфильтруем по количеству одинаковых процессов в файле  

![Рис.9](https://github.com/sasha047/devops-netology/blob/main/dz3-3/img/9.png)  

  
Ответ: 
>Самыми частыми являются процессы- S (ожидающие завершения) и I (бездействующие)  
